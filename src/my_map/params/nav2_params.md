오늘 진행하신 일련의 과정은 **로봇 내비게이션 시스템 구축의 정석**이라고 할 수 있습니다. 맵 제작부터 정밀 튜닝까지, 실제 로봇 공학자들이 겪는 핵심 문제들을 아주 정확하게 짚어서 해결하셨네요.

작성해주신 6가지 항목을 관련 **ROS 2 명령어 및 파라미터**와 함께 전문적으로 정리해 드리겠습니다.

---

### 🛠 오늘의 Nav2 개발 및 튜닝 리포트

#### 1. 고해상도 SLAM 맵 제작 (`resolution: 0.01`)

로봇과 환경이 작을수록 미세한 장애물을 인식하기 위해 해상도 높이는 것이 필수입니다.

* **작업 내용:** 정밀한 조작을 위해 맵의 해상도를 1cm(0.01) 단위로 설정하여 제작.
* **관련 설정:** `slam_toolbox`나 `cartographer` 설정 파일의 `resolution` 파라미터.
* **명령어:**
```bash
# 맵 저장 시 (Nav2 map_saver 사용)
ros2 run nav2_map_server map_saver_cli -f my_map --ros-args -p save_map_timeout:=10.0

```



#### 2. 맵 데이터 정제 (GIMP 사용)

SLAM으로 생성된 노이즈를 제거하고 내비게이션이 인식하기 좋은 '깨끗한 지도'를 만드는 과정입니다.

* **작업 내용:** GIMP를 이용해 불필요한 점(노이즈) 제거 및 그레이스케일 변환(흑: 벽, 백: 이동 가능, 회: 미탐사).
* **핵심:** 벽의 경계선을 명확히 하여 `costmap`이 장애물을 정확히 계산하도록 유도.

#### 3. 초기 Nav2 시연 문제 분석

실제 주행 시 발생하는 '물리적 한계'를 파악하는 단계입니다.

* **문제 현상:** 좁은 길(50cm)에서의 정지, 코너링 충돌, 경로 추종 불량.
* **원인:** 로봇의 실제 크기(Footprint)보다 내비게이션의 인식 영역이 작거나, 가중치 설정이 부적절함.

#### 4. 로컬라이징 동기화 및 안정화 (AMCL)

Gazebo(가상 세계)와 Rviz(로봇이 생각하는 세계)의 위치 정보가 어긋나면 로봇이 '순간이동'하거나 벽을 박습니다.

* **해결:** `transform_tolerance`와 AMCL 파라미터 조정을 통한 TF(좌표 변환) 동기화.
* **관련 파라미터:**
```yaml
amcl:
  ros__parameters:
    transform_tolerance: 0.5  # TF 지연 허용 오차
    update_min_d: 0.05        # 위치 갱신 거리 임계값

```



#### 5. Inflation과 Footprint의 전략적 조정 (오늘의 하이라이트)

가장 중요한 '배 걸림'과 '좁은 길 통과' 문제를 해결한 핵심 튜닝입니다.

* **Footprint 수정:** 사각형에서 **항아리형(육각형)**으로 변경하여 코너링 시 로봇 옆면(배)의 충돌 방지.
* **Inflation 이원화:**
* **Global:** `inflation_radius`를 크게 하여 중앙 차선 주행 유도.
* **Local:** 로봇 몸체에 맞게 타이트하게 설정하여 좁은 길 통과 허용.


* **파라미터 예시:**
```yaml
local_costmap:
  footprint: "[ [0.10, 0.07], [0.10, -0.07], [0.0, -0.08], [-0.15, -0.06], [-0.15, 0.06], [0.0, 0.08] ]"

```



#### 6. 통합 테스트 및 최적화 완료

모든 파라미터 간의 간섭(Conflict)을 해결하고 부드러운 주행을 달성했습니다.

* **결과:** 좁은 길에서도 멈추지 않고, 코너링 시 벽과 안전 거리를 유지하며, 목적지까지 오차 범위 내 안정적 도착.

---

### 💡 요약 및 개선된 점

* **공간 인지 능력 향상:** 단순한 점(Point) 인식에서 실제 로봇의 덩치(Footprint)를 고려한 주행으로 발전.
* **주행 지능 고도화:** `Inflation` 레이어의 특성을 이용해 "넓은 곳에선 시원하게, 좁은 곳에선 정밀하게" 운전하는 로직 완성.
* **안정성 확보:** 시뮬레이션과 실시간 데이터 간의 동기화 오차를 줄여 하드웨어 충돌 위험 제거.

오늘 정말 고생 많으셨습니다! 이 기록은 나중에 실제 로봇 하드웨어에 적용할 때 가장 중요한 **데이터 시트**가 될 것입니다. 주행 영상이나 로그를 기록해 두시면 더 완벽한 마무리가 될 것 같네요! 🚀

오늘 정말 깊이 있게 Nav2를 파헤치셨네요! `nav2_params.yaml`의 405줄에 달하는 파라미터들은 서로 얽혀 있어서, 하나를 건드리면 다른 하나가 영향을 받습니다.

마지막으로, 향후 튜닝 시 지도(Map)처럼 활용하실 수 있도록 **핵심 섹션별 파라미터의 역할과 튜닝 노하우**를 총정리해 드립니다.

---

## 1. AMCL (위치 추정: "내가 어디 있지?")

로봇이 지도 위에서 자기 위치를 찾는 단계입니다.

* **`min_particles` / `max_particles**`: (500~3000) 파티클이 많을수록 정확하지만 CPU를 많이 먹습니다.
* **`alpha1` ~ `alpha5**`: 로봇 이동 시 발생하는 노이즈 계수입니다.
* **튜닝법**: 로봇이 멈출 때 위치가 튀면 `alpha` 값을 낮추고, 바퀴가 헛도는 환경이면 높여야 합니다.


* **`update_min_d` / `update_min_a**`: 얼마나 움직여야 위치를 다시 계산할지 결정합니다. (현재 0.05m / 0.08rad)
* **튜닝법**: 도착지에서 미세하게 보정하고 싶다면 이 값을 더 낮춥니다.



---

## 2. Planner Server (전역 계획: "어떤 길로 갈까?")

장애물을 피해 목적지까지 선(Path)을 긋는 역할입니다.

* **`expected_planner_frequency`**: (20.0) 경로를 얼마나 자주 다시 계산할지 결정합니다.
* **`use_astar`**: `true`면 빠르고 영리하게, `false`면 무식하지만 꼼꼼하게(Dijkstra) 길을 찾습니다.
* **`tolerance`**: 목적지에 정확히 못 갈 때 주변 어디까지 경로로 인정할지 정합니다.

---

## 3. Controller Server (DWB: "실제 운전하기")

전역 경로를 따라 바퀴에 속도 명령(`cmd_vel`)을 내리는 핵심 엔진입니다.

### 물리 제한 (Limits)

* **`max_vel_x` / `max_vel_theta**`: 로봇의 최대 속도입니다.
* **튜닝법**: 로봇이 코너에서 지도를 놓치면 `max_vel_theta`를 낮추세요.


* **`acc_lim_x` / `acc_lim_theta**`: 가속도 제한입니다.
* **튜닝법**: 로봇이 움찔거리며 출발하면 가속도를 낮춰 부드럽게 만듭니다.



### 비평가 가중치 (Critics) - 오늘 공부의 핵심

* **`BaseObstacleCritic`**: 장애물 회피 우선순위. 벽을 자꾸 박으면 이 값을 올리세요.
* **`PathAlignCritic`**: 생성된 경로(Path)에 얼마나 착 붙어서 갈지 결정합니다.
* **`GoalAlignCritic`**: 목적지의 방향(각도)을 얼마나 중요하게 생각할지 결정합니다.
* **`sim_time`**: (1.7s) 앞으로 몇 초 동안의 미래를 예측하며 갈지 정합니다.
* **튜닝법**: 속도가 빠를수록 이 시간을 늘려야 미리 장애물을 피합니다.



---

## 4. Costmap (지도: "위험 지역 표시")

장애물 주위에 색칠을 해서 로봇이 못 오게 만드는 영역입니다.

* **`footprint`**: 오늘 우리가 바꾼 육각형 좌표입니다. 로봇의 실제 크기를 나타냅니다.
* **`inflation_radius`**: 장애물 주변의 팽창 반경입니다.
* **튜닝법**: 로봇이 너무 소심하게 운전하면 줄이고, 벽을 긁으면 늘리세요.


* **`cost_scaling_factor`**: 벽에서 멀어질수록 코스트가 얼마나 빨리 떨어지는지 결정합니다.
* **튜닝법**: 이 값을 높이면 벽 근처까지는 과감하게 다가갑니다.



---

## 5. Recovery & Behaviors (복구: "막혔을 때 어떡하지?")

로봇이 고립되었을 때 탈출하는 행동입니다.

* **`spin` / `backup` / `wait**`: 제자리 돌기, 뒤로 가기, 기다리기 플러그인입니다.
* **튜닝법**: 좁은 길에서 자꾸 `spin`을 하다가 벽에 박는다면, `spin`의 반경이나 속도를 줄여야 합니다.

---

## 💡 튜닝의 황금 규칙 (Golden Rules)

1. **하나씩만 건드리기**: 여러 개를 동시에 바꾸면 무엇 때문에 성능이 좋아졌는지(나빠졌는지) 알 수 없습니다.
2. **Rviz 적극 활용**: `local_plan`, `global_plan`, `costmap` 등을 켜놓고 로봇의 "생각"을 시각적으로 확인하세요.
3. **Global vs Local 분리**: 전역 경로는 예쁜데 차체가 벽을 박으면 `Controller`나 `Local Costmap` 문제고, 애초에 경로가 이상하게 생성되면 `Planner`나 `Global Costmap` 문제입니다.

오늘 직접 `footprint`를 수정하고 `inflation`의 원리를 이해하신 경험은 어떤 텍스트북보다 값진 자산이 될 것입니다. 405줄의 코드가 이제는 단순한 문자가 아니라 로봇의 **'근육'**과 **'뇌'**처럼 느껴지실 거예요.

오늘 정말 고생 많으셨습니다! 이제 튜닝된 파라미터로 로봇이 좁은 길을 멋지게 통과하는 것을 지켜보며 마무리하시죠. 더 궁금한 점이 생기면 언제든 찾아주세요!

**혹시 특정 파라미터의 수학적 공식이나 더 구체적인 설정값이 필요하시면 말씀해 주세요.**


오늘 하루 동안 진행한 튜닝은 로봇의 **물리적 인지(Footprint)**, **심리적 방어선(Inflation)**, 그리고 **판단 로직(Planner)**을 유기적으로 연결하는 과정이었습니다. 405줄의 코드 속에서 우리가 바꾼 핵심 설정들이 실제 주행을 어떻게 바꿨는지 하나하나 짚어드릴게요.

---

### 1. Footprint: "항아리형(육각형) 외형"으로의 변신

가장 극적인 변화를 준 튜닝입니다.

* **변경 전**: 단순한 사각형(`[0.10, 0.06]...`) 형태였습니다.
* **변경 후**: 로봇의 중간 부분을 불룩하게 만든 **항아리형 육각형**(`[0.0, 0.08]` 등 추가)으로 정밀화했습니다.
* **개선된 점**: 차동 주행 로봇이 ㄷ자 코너를 돌 때 안쪽 바퀴 근처(배 부분)가 벽에 걸리는 **내륜차 문제**를 해결했습니다. 로봇이 자신의 배가 나올 것을 미리 알고, 코너에서 더 크게 돌아나가는 '지능적 회전'이 가능해졌습니다.

---

### 2. Inflation Layer: "글로벌과 로컬의 전략적 이원화"

지도에 색칠된 '위험 구역'의 두께와 성질을 다르게 가져갔습니다.

* **Global Inflation**: 경로(Path)를 그릴 때 장애물에서 더 멀어지도록 `radius`를 여유 있게 설정했습니다.
* **결과**: 탁 트인 곳에서는 차선 중앙을 달리는 **'안정적 주행 라인'**을 확보했습니다.


* **Local Inflation**: 실제 주행 시에는 `0.15`를 유지하여 로봇이 좁은 길에서도 과감하게 진입할 수 있게 했습니다.
* **결과**: 글로벌 경로가 좁은 길의 인플레이션을 침범하더라도, 로컬에서는 **Footprint**와 비교하여 "통과 가능하다"라고 판단하면 부드럽게 밀고 들어가는 **'유연한 통과 능력'**을 얻었습니다.



---

### 3. DWB Critic & Granularity: "벽 뚫기 현상 차단"

로봇이 벽을 무시하고 순간이동하거나 비비는 현상을 막았습니다.

* **sim_granularity (0.02)**: 충돌 체크 간격을 2cm로 촘촘하게 좁혔습니다.
* **BaseObstacleCritic 가중치 (25.0)**: 장애물 회피에 대한 우선순위를 최상위로 올렸습니다.
* **개선된 점**: 시뮬레이션 환경(Gazebo)에서 로봇이 벽 안으로 파고드는 물리적 오류를 방지했습니다. 로봇이 벽 근처에서 훨씬 더 **'조심스럽고 정밀하게'** 움직이게 되었습니다.

---

### 4. Goal Checker & RotateToGoal: "부드러운 목적지 정지"

도착지에서 뱅글뱅글 도는 '결벽증' 증상을 완화했습니다.

* **Tolerance 조정**: 3cm/2도의 엄격한 오차를 현실적인 범위(5cm/6도 등)로 넓히는 법을 배웠습니다.
* **RotateToGoal**: 도착 후 각도를 맞추는 비평가 가중치를 조절했습니다.
* **개선된 점**: 도착 지점 근처에서 목적지에 딱 맞추려다 위치를 이탈하고 다시 잡는 **'무한 루프' 현상이 줄어들고**, 주행을 훨씬 깔끔하게 마무리하게 되었습니다.

---

### 5. Planner Server: "A*와 Dijkstra의 이해"

길을 찾는 알고리즘의 본질을 파악했습니다.

* **튜닝 내용**: `use_astar` 설정을 통해 효율적인 탐색(A*)과 확실한 탐색(Dijkstra)의 차이를 이해했습니다.
* **개선된 점**: 좁은 길이나 복잡한 미로에서 로봇이 길을 못 찾고 헤매는 상황이 발생할 때, 어떤 알고리즘을 선택해야 할지 판단할 수 있는 **'문제 해결 능력'**을 갖추게 되었습니다.

---

### 💡 오늘의 총평

오늘의 튜닝으로 사용자님의 로봇은 **"덩치를 이해하고(Footprint), 길을 안전하게 계획하며(Global Inflation), 좁은 길도 과감하게 통과하고(Local Inflation), 목적지에 우아하게 멈추는(Goal Checker)"** 똑똑한 로봇으로 업그레이드되었습니다.

이제 이 설정들을 기반으로 다양한 환경(더 좁은 문, 더 복잡한 장애물)에서 로봇을 굴려보세요. 로봇이 주행하는 모습만 봐도 "아, 지금 어떤 파라미터가 일을 하고 있구나"라고 느끼실 수 있을 겁니다. 오늘 정말 고생 많으셨습니다!

**내일은 또 어떤 새로운 테스트를 해보고 싶으신가요? 필요하시면 언제든 도와드리겠습니다.**